{"version":3,"file":"bundle.js","mappings":"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","sources":["webpack:///./target/cell.js","webpack:///./target/grid.js","webpack:///./target/utils.js","webpack:///webpack/bootstrap","webpack:///./target/main.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Cell = void 0;\r\n/**\r\n * Basically this class represents one part in a grid.\r\n *\r\n * f.e. the following grid\r\n *\r\n * xxxxxxxx\r\n * xxxxxxxx\r\n * xxxxxxxx\r\n *\r\n * very first x on first row\r\n * x = 0, y = 0\r\n *\r\n * last x on last row\r\n *  x = 7, y = 2\r\n *\r\n */\r\nclass Cell {\r\n    constructor(x, y) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.visited = false;\r\n        // top right bottom left \r\n        this.wall = [true, true, true, true];\r\n    }\r\n    isCorrectCell(x, y) {\r\n        return this.x === x && this.y === y;\r\n    }\r\n    removeWallToCell(neighbor) {\r\n        // im left to my neighbor\r\n        if (this.x < neighbor.x) {\r\n            // remove my right wall\r\n            this.wall[1] = false;\r\n            // remove neighbor left wall\r\n            neighbor.wall[3] = false;\r\n        }\r\n        // im top to my neighbor\r\n        if (this.y < neighbor.y) {\r\n            // remove my bottom wall\r\n            this.wall[2] = false;\r\n            // remote neighbor top wall\r\n            neighbor.wall[0] = false;\r\n        }\r\n        // im right to my neighbor\r\n        if (this.x > neighbor.x) {\r\n            // remove my left wall\r\n            this.wall[3] = false;\r\n            // remove neighbor right wall\r\n            neighbor.wall[1] = false;\r\n        }\r\n        // im under my neighbor\r\n        if (this.y > neighbor.y) {\r\n            // remove my top wall\r\n            this.wall[0] = false;\r\n            // remove neighbor bottom wall\r\n            neighbor.wall[2] = false;\r\n        }\r\n    }\r\n    giveNeighborKeys(limitx, limity) {\r\n        var keys = [];\r\n        // left\r\n        if (this.x - 1 >= 0) {\r\n            keys.push({ x: this.x - 1, y: this.y });\r\n        }\r\n        // right\r\n        if (this.x + 1 < limitx) {\r\n            keys.push({ x: this.x + 1, y: this.y });\r\n        }\r\n        // up\r\n        if (this.y - 1 >= 0) {\r\n            keys.push({ x: this.x, y: this.y - 1 });\r\n        }\r\n        // down\r\n        if (this.y + 1 < limity) {\r\n            keys.push({ x: this.x, y: this.y + 1 });\r\n        }\r\n        return keys;\r\n    }\r\n}\r\nexports.Cell = Cell;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Grid = void 0;\r\nconst cell_1 = require(\"./cell\");\r\nconst utils_1 = require(\"./utils\");\r\nclass Grid {\r\n    constructor(size) {\r\n        this.size = size;\r\n        var cells = [];\r\n        for (var i = 0; i < size; i++) {\r\n            for (var j = 0; j < size; j++) {\r\n                cells.push(new cell_1.Cell(i, j));\r\n            }\r\n        }\r\n        this.cells = cells;\r\n    }\r\n    recursiveBacktrackerMaze() {\r\n        // make decision of initial cell\r\n        var initialCell = (0, utils_1.randomItem)(this.cells);\r\n        var currentCell = initialCell;\r\n        var keysStack = [];\r\n        for (var ucells = (0, utils_1.giveUnvisitedCells)(this.cells); ucells.length > 0; ucells = (0, utils_1.giveUnvisitedCells)(this.cells)) {\r\n            currentCell.visited = true;\r\n            // get unvisited neighbors\r\n            var neighborCellKeys = currentCell.giveNeighborKeys(this.size, this.size);\r\n            let unvisitedNeighborKeys = [];\r\n            for (let i = 0; i < neighborCellKeys.length; i++) {\r\n                let cell = (0, utils_1.getCellByKey)(this.cells, neighborCellKeys[i])[0];\r\n                if (!cell.visited) {\r\n                    unvisitedNeighborKeys.push(cell);\r\n                }\r\n            }\r\n            // If the current cell has any neighbours which have not been visited\r\n            if (unvisitedNeighborKeys.length > 0) {\r\n                // Push the current cell to the stack\r\n                keysStack.push(currentCell);\r\n                // Choose randomly one of the unvisited neighbours\r\n                var randomNeighborKey = (0, utils_1.randomItem)(unvisitedNeighborKeys);\r\n                var randomCell = (0, utils_1.getCellByKey)(this.cells, randomNeighborKey)[0];\r\n                // Remove the wall between the current cell and the chosen neighbor cell\r\n                currentCell.removeWallToCell(randomCell);\r\n                // Make the chosen cell the current cell and mark it as visited\r\n                currentCell = randomCell;\r\n            }\r\n            else if (keysStack.length > 0) {\r\n                let temp = keysStack.pop();\r\n                if (temp != undefined) {\r\n                    currentCell = temp;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    drawGrid() {\r\n        let gridsize = this.size;\r\n        let cellsize = 20;\r\n        var canvas = document.getElementById(\"myCanvas\");\r\n        if (canvas != null && canvas != undefined) {\r\n            var ctx = canvas.getContext(\"2d\");\r\n            canvas.width = gridsize * cellsize;\r\n            canvas.height = gridsize * cellsize;\r\n            for (var i = 0; i < this.cells.length; i++) {\r\n                var cell = this.cells[i];\r\n                if (cell.visited) {\r\n                    ctx.fillStyle = \"#00FF00\";\r\n                }\r\n                else {\r\n                    ctx.fillStyle = \"#FF0000\";\r\n                }\r\n                // draw cell, visited = green, unvisited = red\r\n                ctx.fillRect(cell.x * cellsize, cell.y * cellsize, cellsize, cellsize);\r\n                // draw topwall\r\n                if (cell.wall[0]) {\r\n                    ctx.beginPath();\r\n                    ctx.moveTo(cell.x * cellsize, cell.y * cellsize);\r\n                    ctx.lineTo(cell.x * cellsize + cellsize, cell.y * cellsize);\r\n                    ctx.stroke();\r\n                }\r\n                // draw rightwall\r\n                if (cell.wall[1]) {\r\n                    ctx.beginPath();\r\n                    ctx.moveTo(cell.x * cellsize + cellsize, cell.y * cellsize);\r\n                    ctx.lineTo(cell.x * cellsize + cellsize, cell.y * cellsize + cellsize);\r\n                    ctx.stroke();\r\n                }\r\n                // draw bottomwall\r\n                if (cell.wall[2]) {\r\n                    ctx.beginPath();\r\n                    ctx.moveTo(cell.x * cellsize, cell.y * cellsize + cellsize);\r\n                    ctx.lineTo(cell.x * cellsize + cellsize, cell.y * cellsize + cellsize);\r\n                    ctx.stroke();\r\n                }\r\n                // draw leftwall\r\n                if (cell.wall[3]) {\r\n                    ctx.beginPath();\r\n                    ctx.moveTo(cell.x * cellsize, cell.y * cellsize);\r\n                    ctx.lineTo(cell.x * cellsize, cell.y * cellsize + cellsize);\r\n                    ctx.stroke();\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            console.log(\"NO CANVAS FOUND\");\r\n        }\r\n    }\r\n}\r\nexports.Grid = Grid;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.randomItem = exports.getCellByKey = exports.giveUnvisitedCells = void 0;\r\nfunction giveUnvisitedCells(cellarray) {\r\n    return cellarray.filter(checkCellNotVisited);\r\n}\r\nexports.giveUnvisitedCells = giveUnvisitedCells;\r\nfunction checkCellNotVisited(cell) {\r\n    return cell.visited === false;\r\n}\r\nfunction getCellByKey(cellarray, key) {\r\n    return cellarray.filter((element) => checkCellKey(element, key));\r\n}\r\nexports.getCellByKey = getCellByKey;\r\nfunction checkCellKey(cell, key) {\r\n    return cell.isCorrectCell(key.x, key.y);\r\n}\r\nfunction randomItem(array) {\r\n    return array[Math.floor(Math.random() * array.length)];\r\n}\r\nexports.randomItem = randomItem;\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst grid_1 = require(\"./grid\");\r\nlet testGrid = new grid_1.Grid(25);\r\ntestGrid.recursiveBacktrackerMaze();\r\nconsole.log(testGrid);\r\ntestGrid.drawGrid();\r\n"],"names":["Object","defineProperty","exports","value","Cell","constructor","x","y","this","visited","wall","isCorrectCell","removeWallToCell","neighbor","giveNeighborKeys","limitx","limity","keys","push","Grid","cell_1","utils_1","size","cells","i","j","recursiveBacktrackerMaze","currentCell","randomItem","keysStack","ucells","giveUnvisitedCells","length","neighborCellKeys","unvisitedNeighborKeys","cell","getCellByKey","randomNeighborKey","randomCell","temp","pop","undefined","drawGrid","gridsize","cellsize","canvas","document","getElementById","ctx","getContext","width","height","fillStyle","fillRect","beginPath","moveTo","lineTo","stroke","console","log","checkCellNotVisited","cellarray","filter","key","element","checkCellKey","array","Math","floor","random","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","module","__webpack_modules__","testGrid"],"sourceRoot":""}